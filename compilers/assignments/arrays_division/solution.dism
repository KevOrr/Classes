;;; R[0] := 0
;;; R[1] := 1
;;; R[2] := Fill pointer
;;; R[3] := Input value
;;; R[4] := M[i]
;;; R[5] := M[j]
;;; R[6] := Quotient

  mov 0 0                       ; Not necessary, but just to be explicit
  mov 1 1

INPUT:
  rdn 3                         ; Read into R[3]
  beq 3 0 #ENDINPUT             ; If we got a zero, jump to indices prompt
  str 0 0 1                     ; M[R[0]] <- R[1]
  add 0 0 1                     ; Increment fill pointer
  jmp 0 #INPUT                  ; Continue loop

ENDINPUT:
  rdn 4                         ; Prompt for i
  lod 4 4 0                     ; Fetch A[i]
  rdn 5                         ; Prompt for j
  lod 5 5 0                     ; Fetch A[j]

;;; Count number of times that numerator >= denominator after `numerator -= denominator`
DIVIDE:
  blt 4 5 #PRINT                ; If numerator now less than denominator, break
  sub 4 4 5                     ; numerator -= denominator
  add 6 6 1                     ; quotient++
  jmp 0 #DIVIDE                 ; repeat

PRINT:
  ptn 6                         ; Print quotient
  hlt 0
